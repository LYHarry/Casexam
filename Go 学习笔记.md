# GO 学习笔记

## 特点

1.  跨平台、开源
2. 语言简洁、快速、安全、强类型
3. 上手简单、编译迅速
4. 并发(并行)处理

## 目录结构

1. bin 存放编译后的可执行文件
2. pkg 存放编译后的包文件
3. src 存放项目源文件

所有 Go 源文件都应该放置在工作区里的 src 目录下

## 基础知识

1. Go 没有自动类型提升或类型转换
2. **常量的值是在编译的时候确定**
3. 在 Go 中，任何以大写字母开头的变量或者函数或结构体都是被导出的名字。其它包只能访问被导出的函数和变量
4. 在 Go 中，不充许定义不会使用的变量，不充许导入不会使用的包
5. interface{} 类型表示任意类型
6. Go 不支持指针运算
7. Go 不支持类，可以通过给结构体**添加方法**来模拟类
8. Go 不支持继承，可以通过**组合**的方式来模拟继承
9. Go 不支持构造器，可以通过 New 函数 或 NewT 函数来模拟构造函数
10. Go 不支持方法重载

### 运算符

1. 简短声明(:=)操作符左边的所有变量都要有初始值
2. := 操作符左边**至少有一个**变量是尚未声明的
3. byte 是 uint8 的别名
4. rune 是 int32 的别名，rune 表示一个代码点。代码点无论占用多少个字节，都可以用一个 rune 来表示
5. 用简短语法声明对象(二维数组，结构体等)时，最后一个对象末尾的逗号是必需的
6. **/** 运算符不是整除
7. i.(T)  类型断言，用于提取接口的底层值
8. i.(type)  类型选择，用于提取接口的具体类型

### int 类型

int 类型会根据不同的底层平台，表示 32 或 64 位整型。

uint 类型会根据不同的底层平台，表示 32 或 64 位无符号整型。

大小：在 32 位系统下是 32 位，而在 64 位系统下是 64 位。

范围：在 32 位系统下是 -2147483648～2147483647，而在 64 位系统是 -9223372036854775808～9223372036854775807。

### init 函数

init 函数不能有任何返回值类型和参数，也不能显式地调用它。

一个包(文件夹)可以有多个 init 函数（在一个文件或分布于多个文件中），它们将按照编译器解析它们的顺序进行调用。

包的初始化顺序如下：

1. 首先初始化包级别的变量

2. 紧接着调用 init 函数。

3. 最后调用 main 函数或其他函数

如果一个包导入了另一个包，会先初始化被导入的包。

### Defer

并非在调用延迟函数的时候才确定实参，而是当执行 defer 语句的时候，就会对延迟函数的实参进行求值。

当一个函数内多次调用 defer 时，会形成一个 defer 栈，按照后进先出的顺序执行。

### 结构体
1. 匿名字段虽然没有名称，但其实匿名字段的名称就默认为它的类型
2. 结构体是值类型

## 语句

### if-else

1. Go 语言里的 { } 是必要的，即使在 { } 之间只有一条语句
2. else 语句要在 if 语句的大括号 } 之后的同一行中
3. 与 if 匹配的左括号 { 必须与 if 和表达式放在同一行
4. 在 Go 中，不支持三目运算符

### switch

在 Go 中，每执行完一个 case 后，会从 switch 语句中跳出来，不再做后续 case 的判断和执行。使用 **fallthrough** 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中，不跳出 switch 语句。

### 方法/函数

1. 函数使用指针参数只接受指针，而使用指针接收器的方法可以使用值接收器和指针接收器
2. 函数使用值参数，则只能接受值参数。函数使用指针参数，则只接受指针参数
3. 方法使用值接收器，可以接受值接收器和指针接收器。方法使用指针接收器，可以接受值接收器和指针接收器
4. 方法接收器类型的定义和方法的定义应该在同一个包中

## 数组

1. 切片本身不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中(所引用的数组上)
2. 当新的元素被添加到切片时，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。新切片的容量是旧切片的两倍
3. 切片作为参数传递时是以引用类型传递
4. 当使用 for range 遍历 map 时，不保证每次执行程序获取的元素顺序相同
5. 在 Go 中，数组是值类型而不是引用类型

## 并发

### 信道

1. 箭头对于**信道**来说是向外指，就是读取信道数据，箭头指向了**信道**，就是把数据写入信道
2. 写入和读取数据，信道默认是阻塞的，不会出现同一数据又在读又在写的情况

### select

select 语句会一直阻塞，直到发送/接收操作准备就绪。如果有多个信道操作准备完毕，select 会随机地选取其中之一执行。

### Mutex

所有在 Lock 和 Unlock 之间的代码，都只能由一个 Go 协程执行

解决竟态条件(多个协程共享资源)：当 Go 协程需要与其他协程通信时，可以使用信道。而当只允许一个协程访问临界区时，可以使用 Mutex。

## 错误异常

当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪，最后程序终止。

只有在延迟函数的内部，调用 recover 才有用。在延迟函数内调用 recover，可以取到 panic 的错误信息，并且停止 panic 续发事件，程序运行恢复正常。如果在延迟函数的外部调用 recover，就不能停止 panic 续发事件。

recover 不能恢复一个不同协程的 panic，只有在相同的 Go 协程中调用 recover 才管用。

使用 runtime 包下的 debug 包中的 PrintStack() 函数打印堆栈跟踪

## 反射

NumField 方法只能在结构体上使用。

relfect.Kind 和 reflect.TypeOf 区别：Type 表示 interface{} 的实际类型（main.Order)，而 Kind 表示该类型的特定类别（struct）。

## 格式化

https://blog.csdn.net/qq_34777600/article/details/81266453

1. %T 输出变量类型
2. %d 输出字节大小，输出整型
3. %.2f 输出保留两位小数的浮点数
4. %x 输出字符16进制编码
5. %t 输出布尔类型
6. %s 输出字符串
7. %c 输出字符型（按asc码输出）

## 学习资料

1. Go 系列教程  https://studygolang.com/subject/2
2. Go 入门教程 http://c.biancheng.net/golang